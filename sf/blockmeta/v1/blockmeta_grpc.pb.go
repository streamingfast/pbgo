// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.5
// source: sf/blockmeta/v1/blockmeta.proto

package pbblockmeta

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TimeToIDClient is the client API for TimeToID service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TimeToIDClient interface {
	At(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	After(ctx context.Context, in *RelativeTimeRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	Before(ctx context.Context, in *RelativeTimeRequest, opts ...grpc.CallOption) (*BlockResponse, error)
}

type timeToIDClient struct {
	cc grpc.ClientConnInterface
}

func NewTimeToIDClient(cc grpc.ClientConnInterface) TimeToIDClient {
	return &timeToIDClient{cc}
}

func (c *timeToIDClient) At(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.TimeToID/At", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeToIDClient) After(ctx context.Context, in *RelativeTimeRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.TimeToID/After", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeToIDClient) Before(ctx context.Context, in *RelativeTimeRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.TimeToID/Before", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimeToIDServer is the server API for TimeToID service.
// All implementations should embed UnimplementedTimeToIDServer
// for forward compatibility
type TimeToIDServer interface {
	At(context.Context, *TimeRequest) (*BlockResponse, error)
	After(context.Context, *RelativeTimeRequest) (*BlockResponse, error)
	Before(context.Context, *RelativeTimeRequest) (*BlockResponse, error)
}

// UnimplementedTimeToIDServer should be embedded to have forward compatible implementations.
type UnimplementedTimeToIDServer struct {
}

func (UnimplementedTimeToIDServer) At(context.Context, *TimeRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method At not implemented")
}
func (UnimplementedTimeToIDServer) After(context.Context, *RelativeTimeRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method After not implemented")
}
func (UnimplementedTimeToIDServer) Before(context.Context, *RelativeTimeRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Before not implemented")
}

// UnsafeTimeToIDServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimeToIDServer will
// result in compilation errors.
type UnsafeTimeToIDServer interface {
	mustEmbedUnimplementedTimeToIDServer()
}

func RegisterTimeToIDServer(s grpc.ServiceRegistrar, srv TimeToIDServer) {
	s.RegisterService(&TimeToID_ServiceDesc, srv)
}

func _TimeToID_At_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeToIDServer).At(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.TimeToID/At",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeToIDServer).At(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeToID_After_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelativeTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeToIDServer).After(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.TimeToID/After",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeToIDServer).After(ctx, req.(*RelativeTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeToID_Before_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelativeTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeToIDServer).Before(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.TimeToID/Before",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeToIDServer).Before(ctx, req.(*RelativeTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TimeToID_ServiceDesc is the grpc.ServiceDesc for TimeToID service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimeToID_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sf.blockmeta.v1.TimeToID",
	HandlerType: (*TimeToIDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "At",
			Handler:    _TimeToID_At_Handler,
		},
		{
			MethodName: "After",
			Handler:    _TimeToID_After_Handler,
		},
		{
			MethodName: "Before",
			Handler:    _TimeToID_Before_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sf/blockmeta/v1/blockmeta.proto",
}

// BlockIDClient is the client API for BlockID service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlockIDClient interface {
	NumToID(ctx context.Context, in *NumToIDRequest, opts ...grpc.CallOption) (*BlockIDResponse, error)
	// Query the CURRENT irreversible block
	LIBID(ctx context.Context, in *LIBRequest, opts ...grpc.CallOption) (*BlockIDResponse, error)
}

type blockIDClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockIDClient(cc grpc.ClientConnInterface) BlockIDClient {
	return &blockIDClient{cc}
}

func (c *blockIDClient) NumToID(ctx context.Context, in *NumToIDRequest, opts ...grpc.CallOption) (*BlockIDResponse, error) {
	out := new(BlockIDResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.BlockID/NumToID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockIDClient) LIBID(ctx context.Context, in *LIBRequest, opts ...grpc.CallOption) (*BlockIDResponse, error) {
	out := new(BlockIDResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.BlockID/LIBID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockIDServer is the server API for BlockID service.
// All implementations should embed UnimplementedBlockIDServer
// for forward compatibility
type BlockIDServer interface {
	NumToID(context.Context, *NumToIDRequest) (*BlockIDResponse, error)
	// Query the CURRENT irreversible block
	LIBID(context.Context, *LIBRequest) (*BlockIDResponse, error)
}

// UnimplementedBlockIDServer should be embedded to have forward compatible implementations.
type UnimplementedBlockIDServer struct {
}

func (UnimplementedBlockIDServer) NumToID(context.Context, *NumToIDRequest) (*BlockIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NumToID not implemented")
}
func (UnimplementedBlockIDServer) LIBID(context.Context, *LIBRequest) (*BlockIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LIBID not implemented")
}

// UnsafeBlockIDServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockIDServer will
// result in compilation errors.
type UnsafeBlockIDServer interface {
	mustEmbedUnimplementedBlockIDServer()
}

func RegisterBlockIDServer(s grpc.ServiceRegistrar, srv BlockIDServer) {
	s.RegisterService(&BlockID_ServiceDesc, srv)
}

func _BlockID_NumToID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumToIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockIDServer).NumToID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.BlockID/NumToID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockIDServer).NumToID(ctx, req.(*NumToIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockID_LIBID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LIBRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockIDServer).LIBID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.BlockID/LIBID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockIDServer).LIBID(ctx, req.(*LIBRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlockID_ServiceDesc is the grpc.ServiceDesc for BlockID service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlockID_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sf.blockmeta.v1.BlockID",
	HandlerType: (*BlockIDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NumToID",
			Handler:    _BlockID_NumToID_Handler,
		},
		{
			MethodName: "LIBID",
			Handler:    _BlockID_LIBID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sf/blockmeta/v1/blockmeta.proto",
}

// ForksClient is the client API for Forks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ForksClient interface {
	Resolve(ctx context.Context, in *ForkResolveRequest, opts ...grpc.CallOption) (*ForkResolveResponse, error)
}

type forksClient struct {
	cc grpc.ClientConnInterface
}

func NewForksClient(cc grpc.ClientConnInterface) ForksClient {
	return &forksClient{cc}
}

func (c *forksClient) Resolve(ctx context.Context, in *ForkResolveRequest, opts ...grpc.CallOption) (*ForkResolveResponse, error) {
	out := new(ForkResolveResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.Forks/Resolve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ForksServer is the server API for Forks service.
// All implementations should embed UnimplementedForksServer
// for forward compatibility
type ForksServer interface {
	Resolve(context.Context, *ForkResolveRequest) (*ForkResolveResponse, error)
}

// UnimplementedForksServer should be embedded to have forward compatible implementations.
type UnimplementedForksServer struct {
}

func (UnimplementedForksServer) Resolve(context.Context, *ForkResolveRequest) (*ForkResolveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resolve not implemented")
}

// UnsafeForksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ForksServer will
// result in compilation errors.
type UnsafeForksServer interface {
	mustEmbedUnimplementedForksServer()
}

func RegisterForksServer(s grpc.ServiceRegistrar, srv ForksServer) {
	s.RegisterService(&Forks_ServiceDesc, srv)
}

func _Forks_Resolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForkResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForksServer).Resolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.Forks/Resolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForksServer).Resolve(ctx, req.(*ForkResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Forks_ServiceDesc is the grpc.ServiceDesc for Forks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Forks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sf.blockmeta.v1.Forks",
	HandlerType: (*ForksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Resolve",
			Handler:    _Forks_Resolve_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sf/blockmeta/v1/blockmeta.proto",
}

// ChainDiscriminatorClient is the client API for ChainDiscriminator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChainDiscriminatorClient interface {
	InLongestChain(ctx context.Context, in *InLongestChainRequest, opts ...grpc.CallOption) (*InLongestChainResponse, error)
	GetBlockInLongestChain(ctx context.Context, in *GetBlockInLongestChainRequest, opts ...grpc.CallOption) (*GetBlockInLongestChainResponse, error)
}

type chainDiscriminatorClient struct {
	cc grpc.ClientConnInterface
}

func NewChainDiscriminatorClient(cc grpc.ClientConnInterface) ChainDiscriminatorClient {
	return &chainDiscriminatorClient{cc}
}

func (c *chainDiscriminatorClient) InLongestChain(ctx context.Context, in *InLongestChainRequest, opts ...grpc.CallOption) (*InLongestChainResponse, error) {
	out := new(InLongestChainResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.ChainDiscriminator/InLongestChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainDiscriminatorClient) GetBlockInLongestChain(ctx context.Context, in *GetBlockInLongestChainRequest, opts ...grpc.CallOption) (*GetBlockInLongestChainResponse, error) {
	out := new(GetBlockInLongestChainResponse)
	err := c.cc.Invoke(ctx, "/sf.blockmeta.v1.ChainDiscriminator/GetBlockInLongestChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainDiscriminatorServer is the server API for ChainDiscriminator service.
// All implementations should embed UnimplementedChainDiscriminatorServer
// for forward compatibility
type ChainDiscriminatorServer interface {
	InLongestChain(context.Context, *InLongestChainRequest) (*InLongestChainResponse, error)
	GetBlockInLongestChain(context.Context, *GetBlockInLongestChainRequest) (*GetBlockInLongestChainResponse, error)
}

// UnimplementedChainDiscriminatorServer should be embedded to have forward compatible implementations.
type UnimplementedChainDiscriminatorServer struct {
}

func (UnimplementedChainDiscriminatorServer) InLongestChain(context.Context, *InLongestChainRequest) (*InLongestChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InLongestChain not implemented")
}
func (UnimplementedChainDiscriminatorServer) GetBlockInLongestChain(context.Context, *GetBlockInLongestChainRequest) (*GetBlockInLongestChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInLongestChain not implemented")
}

// UnsafeChainDiscriminatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChainDiscriminatorServer will
// result in compilation errors.
type UnsafeChainDiscriminatorServer interface {
	mustEmbedUnimplementedChainDiscriminatorServer()
}

func RegisterChainDiscriminatorServer(s grpc.ServiceRegistrar, srv ChainDiscriminatorServer) {
	s.RegisterService(&ChainDiscriminator_ServiceDesc, srv)
}

func _ChainDiscriminator_InLongestChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InLongestChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainDiscriminatorServer).InLongestChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.ChainDiscriminator/InLongestChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainDiscriminatorServer).InLongestChain(ctx, req.(*InLongestChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainDiscriminator_GetBlockInLongestChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockInLongestChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainDiscriminatorServer).GetBlockInLongestChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sf.blockmeta.v1.ChainDiscriminator/GetBlockInLongestChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainDiscriminatorServer).GetBlockInLongestChain(ctx, req.(*GetBlockInLongestChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChainDiscriminator_ServiceDesc is the grpc.ServiceDesc for ChainDiscriminator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChainDiscriminator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sf.blockmeta.v1.ChainDiscriminator",
	HandlerType: (*ChainDiscriminatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InLongestChain",
			Handler:    _ChainDiscriminator_InLongestChain_Handler,
		},
		{
			MethodName: "GetBlockInLongestChain",
			Handler:    _ChainDiscriminator_GetBlockInLongestChain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sf/blockmeta/v1/blockmeta.proto",
}
